from random import randint
money_player1 = 100
money_player2 = 100

def get_rate():
    general_rate=0

    while general_rate == 0:
        rate1=int(input("Player1 please enter your rate "))
        rate2=int(input("Player2 please enter your rate "))

        if rate1 == rate2:
            general_rate=rate2
            print("Thanks")
        else:
            print("Your rate not equal, try one more time")
    return general_rate

def shake_cubes(username):
    input(username + " shake cube1")
    try1=randint(1,6)
    print(try1)
    input(username + " shake cube2")
    try2=randint(1,6)
    print(try2)
    input(username + " shake cube3")
    try3=randint(1,6)
    print(try2)
    return try1, try2, try3

def chouse_winner():
    player1=shake_cubes("player1")
    player2=shake_cubes("player2")

    sum_player1=sum(player1)
    sum_player2=sum(player2)
    print("Player1 =", player1, "Total sum=",sum_player1)
    print("Player2 =", player2, "Total sum=",sum_player2)


    if sum_player1 > sum_player2:
        print("Player1 is winer")
        return "P1"
    elif sum_player1 < sum_player2:
        print("Player2 is winer")
        return "P2"
    else:
        print("Results are equal")
        return None


while money_player1 >= 1 and money_player2 >= 1:
    rate=get_rate()

    if rate > money_player1 or rate > money_player2:
        print("Hey, you have no enough money")
    else:
        winner=chouse_winner()

        if winner == "P1":
            money_player1=money_player1+rate
            money_player2=money_player2-rate
        elif winner == "P2":
            money_player1=money_player1-rate
            money_player2=money_player2+rate
        else:
            print("No winners no loosers")
        print('money_player1={} money_player={}'.format(money_player1, money_player2))
        #print("money_player1 =", money_player1, "money_player =2", money_player2)

else:
    print("Thanks for game")


'''
Напишем игру в кости со следующими правилами:
Два игрока, бросают два кубика, с гранями от 1 до 6 очков (Обычные игральные шестигранники). Каждый игрок, бросает кубики три раза подряд.
Игроки должны установить одинаковую ставку для того, чтобы начать играть. Ставка будет запрашиваться до тех пор, пока игрок 1 и игрок 2 не введут одинаковую ставку для игры.
После чего, каждый пользователь бросает три раза подряд кубики, у кого общая сумма выпавших очков будет больше, тот забирает себе выигрыш. Игра длиться до тех пор,
пока у пользователей есть монеты.

Общая структура приложения:
Две переменные с названиями money_player1 и money_player2, изначально устанавливаются в 100 - это и есть исходное значение монет для игрока один и игрока два соответственно.
Описывается функция, которая опрашивает пользователей на предмет ставки до тех пор, пока пользователи не введут одинаковую цифру, после чего,
функция возвращает результат в виде введенного числа.
Описывается функция, которая позволяет пользователю бросить кубики три раза подряд, после чего возвращает общую сумму выпавших очков.
Описывается функция, которая сверяет результаты пользователей и перемещает монеты, согласно тому, кто выиграл на данном этапе.
Описывается главная функция, которая отвечает за общее выполнение приложения.

Опишем функцию, которая опрашивает пользователей на предмет ставки, предположем, функция будет называться get_rate:
Код функции записываем в вечном while со значением True Т.К. мы должны запрашивать пользователей о ставке, пока не получим одинаковые значения.
Просим первого пользователя ввести свою ставку и предоставляет пользовательский ввод. Результат ввода должен быть целым числом.
Проверяем, чтобі пользователь не ввел монет больше, чем находится в его переменной money_player1, если ввел сумму больше, говорим чтобы переввел и континюем цикл.
Просим второго пользователя ввести ставку и также предоставляем пользовательский ввод. Результат должен быть целым числом.
Также проверяем на ссумму ввода для второго игрока money_player2.
Сверяем введенные значения и если они совпадают, ретурним введенное значение. Если результат не совпадает, сообщаем о том,
что ставки не совпали и цикл начинает свою работу заново.

Опишем функцию, которая позволяет бросать кубики три раза подряд. ПОскольку нам нужны рандомные значения,
мы воспользуемся функцией рандомайзера randint, для чего вначале файла, запишем следующее:
from random import randint
Теперь у нас есть функция randint, которая
принимает два числовых аргумента и возвращает случайное число в диапазоне указанных чисел.
Именно она, поможет организовать нам случайное выпадение очков на кубиках. Предположем, что функция будет называться
throw_dice.
В самом простом варианте, сообщаем пользователю что-то в духе: 'для того, чтобы бросить кубики, нажмите Энтер'
после чего, просто вызываем функцию input(), чтобы консоль заблокировалась до нажатия энтер. Это, скорее всего,
некое украшательство, чем необходимые манипуляции, но так пользователь сможет бросать кубики, нажимая энтер, а не просто видеть, как они сами выстреливаются.
После этого, нам необходимо сгенерировать два случайных числа для первого кубика и для второго кубика,
предположем, что переменные для значений, будут называться cube1 и cube2. Два раза подряд, вызываем randint,
с аргументами 1 и 6, записывая значения в указанные переменные. Теперь мы получили два числа, которые представляют собой результаты броска двух кубиков.
Сообщаем пользователю что-то в духе: 'Кубики покатились и... Выпало {0} и {1}'.format(cube1, cube2)
Теперь нам нужно сплюсовать данные двух кубиков, занесем результат в переменную result.
Это был только первый бросок, таких броска нам необходимо сделать еще два.
В простом варианте, опять говорим пользователю, чтобы он нажал энтер для того, чтобы бросить кубики, вызываем input()
Опять вызываем randint и записываем значения в cube1 и cube2
Опять сообщаем пользователю, что кубики покатились и выводим получившиеся числа.
Но на второй и третий раз, нам нужно приплюсовать предыдущий результат result и сумму двух кубиков
result = result+cube1+cube2
потому что нам необходимо собрать общую сумму всех бросков.
На третий раз делаем также, как и на второй. (Лучше данный подход организовать через while, если есть понимание,
как Т.Е. 3 броска и суммирование происходит при трех выполнениях цикла, если нет, выполняем согласно вышеуказанным инструкциям).
После третьего броска, ретурним result.

Описываем функцию, которая сверяет результаты ходов пользователей, предположем, что функция называется check_step:
Функция принимает три аргумента, это будут результаты бросков первого и второго пользователей, а также ставка.
Предположем, что аргументы мы назовем p1, p2 и rate.
Поскольку функции будет необходимо менять количество монет пользователей, мы дадим ей такую возможность, написав в самом начале блока кода функции:
global money_player1
global money_player2
Таким образом, мы предоставляем функции возможность, менять глобальные переменные.
Функция сразу же сообщает примерно следующее: 'Результат первого игрока: {0}. Результат второго игрока: {1}'.format(p1, p2)
После чего определяет, у кого результат больше, если больше результат у первого игрока p1, сообщаем, что победил игрок один,
после чего отнимаем ставку, которую мы принимаем в аргумент rate, от money_player2 и плюсуем ставку для money_player1.
Если больше результат у пользователя 2 p2, соответственно проделываем все те же манипуляции, только сообщаем, что победил игрок 2 и отнимаем ставку у первого,
 и добавляем второму.


Описываем главную функцию, которая называется main.
Весь код функции main, будет проходить в цикле while, который должен выполняться до тех пор,
пока money_player1 и money_player2 не будут равны нулю Т.Е. до тех пор, пока у пользователей остаются монеты.
Далее вызываем функцию get_rate, и сохраняем результат этой функции в переменную rate.
После чего, сообщаем, что сейчас ход игрока 1
Вызываем функцию throw_dice и записываем результат функции в переменную result1.
После чего, говорим, что теперь ход пользователя 2
Опять вызываем функцию throw_dice и записываем результат в result2.
После чего, вызываем функцию check_step и передаем ей в качестве аргументов result1, result2, rate.
На этом код игры заканчивается. Для запуска игры, необходимо просто вызвать функцию main(). Для этого,
достаточно вызвать функцию main() в конце файла и при каждом запуске кода, игра сразу же будет стартовать.

'''